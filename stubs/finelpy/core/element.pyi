"""
Element submodule
"""
from __future__ import annotations
import collections.abc
import finelpy.core.geometry
import finelpy.core.material
import numpy
import numpy.typing
import typing
__all__: list[str] = ['ConstitutiveType', 'Element', 'ElementShape', 'IElementPhysics', 'IntegrationGeometry', 'ModelType', 'ShapeType', 'create_element', 'eval_lagrange', 'eval_lagrange_derivative', 'get_integration_points', 'move_element_to_Cpp']
class ConstitutiveType:
    """
    Members:
    
      PYTHON_CONSTITUTIVE
    
      BAR_LINEAR_ELASTIC
    
      BEAM_LINEAR_ELASTIC
    
      PLANE_STRESS
    
      PLANE_STRAIN
    
      SOLID_LINEAR_ELASTIC
    """
    BAR_LINEAR_ELASTIC: typing.ClassVar[ConstitutiveType]  # value = <ConstitutiveType.BAR_LINEAR_ELASTIC: 1>
    BEAM_LINEAR_ELASTIC: typing.ClassVar[ConstitutiveType]  # value = <ConstitutiveType.BEAM_LINEAR_ELASTIC: 2>
    PLANE_STRAIN: typing.ClassVar[ConstitutiveType]  # value = <ConstitutiveType.PLANE_STRAIN: 4>
    PLANE_STRESS: typing.ClassVar[ConstitutiveType]  # value = <ConstitutiveType.PLANE_STRESS: 3>
    PYTHON_CONSTITUTIVE: typing.ClassVar[ConstitutiveType]  # value = <ConstitutiveType.PYTHON_CONSTITUTIVE: 0>
    SOLID_LINEAR_ELASTIC: typing.ClassVar[ConstitutiveType]  # value = <ConstitutiveType.SOLID_LINEAR_ELASTIC: 5>
    __members__: typing.ClassVar[dict[str, ConstitutiveType]]  # value = {'PYTHON_CONSTITUTIVE': <ConstitutiveType.PYTHON_CONSTITUTIVE: 0>, 'BAR_LINEAR_ELASTIC': <ConstitutiveType.BAR_LINEAR_ELASTIC: 1>, 'BEAM_LINEAR_ELASTIC': <ConstitutiveType.BEAM_LINEAR_ELASTIC: 2>, 'PLANE_STRESS': <ConstitutiveType.PLANE_STRESS: 3>, 'PLANE_STRAIN': <ConstitutiveType.PLANE_STRAIN: 4>, 'SOLID_LINEAR_ELASTIC': <ConstitutiveType.SOLID_LINEAR_ELASTIC: 5>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Element:
    def B(self, loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"], displacement: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"] | None = None) -> numpy.ndarray:
        ...
    def D(self, loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"] | None = None, displacement: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"] | None = None) -> numpy.ndarray:
        ...
    def J(self, loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"] | None = None) -> numpy.ndarray:
        ...
    def Ke(self, displacement: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"] | None = None) -> numpy.ndarray:
        ...
    def Me(self, displacement: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"] | None = None) -> numpy.ndarray:
        ...
    def N(self, loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"], displacement: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"] | None = None) -> numpy.ndarray:
        ...
    def N_shape(self, loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
        ...
    def __init__(self) -> None:
        ...
    def copy(self, arg0: bool) -> Element:
        ...
    def copy_to(self, arg0: Element) -> None:
        ...
    def dNdx(self, loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"], displacement: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"] | None = None) -> numpy.ndarray:
        ...
    def dNdx_shape(self, loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> numpy.ndarray:
        ...
    def dNdxi_shape(self, loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> numpy.ndarray:
        ...
    def detJ(self, loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"] | None = None) -> float:
        ...
    def get_strain(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"], arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
        ...
    def get_stress(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"], arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
        ...
    def integration_pair(self, num_points: typing.SupportsInt = 0) -> list:
        ...
    @typing.overload
    def set_node_numbering(self, arg0: collections.abc.Sequence[typing.SupportsInt], arg1: numpy.ndarray[float, shape=(n,3)]) -> None:
        ...
    @typing.overload
    def set_node_numbering(self, arg0: collections.abc.Sequence[typing.SupportsInt]) -> None:
        ...
    def set_number_integration_points(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def constitutive(self) -> ConstitutiveType:
        ...
    @property
    def dofs(self) -> list[...]:
        ...
    @property
    def dofs_per_node(self) -> int:
        ...
    @property
    def edges(self) -> list[finelpy.core.geometry.Line]:
        ...
    @property
    def integration_points(self, arg1: typing.SupportsInt) -> numpy.ndarray[float, shape=(n,3)]:
        ...
    @property
    def integration_weights(self, arg1: typing.SupportsInt) -> list[float]:
        ...
    @property
    def is_linear(self) -> bool:
        ...
    @property
    def linear_material(self) -> bool:
        ...
    @property
    def linear_physics(self) -> bool:
        ...
    @property
    def model(self) -> ModelType:
        ...
    @property
    def node_numbering(self) -> list[int]:
        ...
    @property
    def nodes(self) -> numpy.ndarray[float, shape=(n,3)]:
        ...
    @property
    def number_of_integration(self) -> int:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def shape(self) -> ShapeType:
        ...
    @property
    def supports_strain(self) -> bool:
        ...
    @property
    def supports_stress(self) -> bool:
        ...
    @property
    def surfaces(self) -> list[finelpy.core.geometry.IArea]:
        ...
class ElementShape:
    def J(self, element_nodes: numpy.ndarray[float, shape=(n,3)], loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"] = None) -> numpy.ndarray:
        ...
    def N(self, loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
        ...
    def __init__(self) -> None:
        ...
    def dNdx(self, element_nodes: numpy.ndarray[float, shape=(n,3)], loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> numpy.ndarray:
        ...
    def dNdxi(self, loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> numpy.ndarray:
        ...
    def detJ(self, element_nodes: numpy.ndarray[float, shape=(n,3)], loc: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"] = None) -> float:
        ...
    @property
    def dim(self) -> int:
        ...
    @property
    def integration_domain(self) -> IntegrationGeometry:
        ...
    @property
    def number_of_nodes(self) -> int:
        ...
    @property
    def shape(self) -> ShapeType:
        ...
    @property
    def shape_order(self) -> int:
        ...
class IElementPhysics:
    pass
class IntegrationGeometry:
    """
    Members:
    
      REGULAR
    
      TRIANGLE
    """
    REGULAR: typing.ClassVar[IntegrationGeometry]  # value = <IntegrationGeometry.REGULAR: 0>
    TRIANGLE: typing.ClassVar[IntegrationGeometry]  # value = <IntegrationGeometry.TRIANGLE: 1>
    __members__: typing.ClassVar[dict[str, IntegrationGeometry]]  # value = {'REGULAR': <IntegrationGeometry.REGULAR: 0>, 'TRIANGLE': <IntegrationGeometry.TRIANGLE: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ModelType:
    """
    Members:
    
      PYTHON_PHYSICS
    
      BAR_STRUCTURAL
    
      BEAM_STRUCTURAL
    
      PLANE_STRUCTURAL
    
      SOLID_STRUCTURAL
    
      THERMAL_CONDUCTION_1D
    
      THERMAL_CONDUCTION_2D
    
      THERMAL_CONDUCTION_3D
    """
    BAR_STRUCTURAL: typing.ClassVar[ModelType]  # value = <ModelType.BAR_STRUCTURAL: 1>
    BEAM_STRUCTURAL: typing.ClassVar[ModelType]  # value = <ModelType.BEAM_STRUCTURAL: 2>
    PLANE_STRUCTURAL: typing.ClassVar[ModelType]  # value = <ModelType.PLANE_STRUCTURAL: 3>
    PYTHON_PHYSICS: typing.ClassVar[ModelType]  # value = <ModelType.PYTHON_PHYSICS: 0>
    SOLID_STRUCTURAL: typing.ClassVar[ModelType]  # value = <ModelType.SOLID_STRUCTURAL: 4>
    THERMAL_CONDUCTION_1D: typing.ClassVar[ModelType]  # value = <ModelType.THERMAL_CONDUCTION_1D: 5>
    THERMAL_CONDUCTION_2D: typing.ClassVar[ModelType]  # value = <ModelType.THERMAL_CONDUCTION_2D: 6>
    THERMAL_CONDUCTION_3D: typing.ClassVar[ModelType]  # value = <ModelType.THERMAL_CONDUCTION_3D: 7>
    __members__: typing.ClassVar[dict[str, ModelType]]  # value = {'PYTHON_PHYSICS': <ModelType.PYTHON_PHYSICS: 0>, 'BAR_STRUCTURAL': <ModelType.BAR_STRUCTURAL: 1>, 'BEAM_STRUCTURAL': <ModelType.BEAM_STRUCTURAL: 2>, 'PLANE_STRUCTURAL': <ModelType.PLANE_STRUCTURAL: 3>, 'SOLID_STRUCTURAL': <ModelType.SOLID_STRUCTURAL: 4>, 'THERMAL_CONDUCTION_1D': <ModelType.THERMAL_CONDUCTION_1D: 5>, 'THERMAL_CONDUCTION_2D': <ModelType.THERMAL_CONDUCTION_2D: 6>, 'THERMAL_CONDUCTION_3D': <ModelType.THERMAL_CONDUCTION_3D: 7>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ShapeType:
    """
    Members:
    
      PYTHON_SHAPE
    
      LINE
    
      TRI3
    
      QUAD4
    
      QUAD9
    
      HEX8
    """
    HEX8: typing.ClassVar[ShapeType]  # value = <ShapeType.HEX8: 5>
    LINE: typing.ClassVar[ShapeType]  # value = <ShapeType.LINE: 1>
    PYTHON_SHAPE: typing.ClassVar[ShapeType]  # value = <ShapeType.PYTHON_SHAPE: 0>
    QUAD4: typing.ClassVar[ShapeType]  # value = <ShapeType.QUAD4: 3>
    QUAD9: typing.ClassVar[ShapeType]  # value = <ShapeType.QUAD9: 4>
    TRI3: typing.ClassVar[ShapeType]  # value = <ShapeType.TRI3: 2>
    __members__: typing.ClassVar[dict[str, ShapeType]]  # value = {'PYTHON_SHAPE': <ShapeType.PYTHON_SHAPE: 0>, 'LINE': <ShapeType.LINE: 1>, 'TRI3': <ShapeType.TRI3: 2>, 'QUAD4': <ShapeType.QUAD4: 3>, 'QUAD9': <ShapeType.QUAD9: 4>, 'HEX8': <ShapeType.HEX8: 5>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
def create_element(shape_type: finelpy.core.element.ShapeType | finelpy.core.element.ElementShape, model_type: finelpy.core.element.ModelType | finelpy.core.element.IElementPhysics, constitutive_type: finelpy.core.element.ConstitutiveType | finelpy.core.material.IConstitutiveModel, material: finelpy.core.material.Material = None) -> Element:
    ...
def eval_lagrange(xi: typing.SupportsFloat, order: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
    ...
def eval_lagrange_derivative(xi: typing.SupportsFloat, order: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
    ...
def get_integration_points(number_of_points: typing.SupportsInt, geometry: IntegrationGeometry = ..., dimensions: typing.SupportsInt = 1) -> tuple:
    ...
def move_element_to_Cpp(arg0: typing.Any) -> Element:
    ...
